---
import Layout from '../layouts/Layout.astro';
import DashboardContent from '../components/DashboardContent.jsx';
import Balatro from '../components/Balatro.jsx';
import { createClient } from '@supabase/supabase-js';

// Server-side auth check and data fetching
const accessToken = Astro.cookies.get('sb-access-token')?.value;
const user = Astro.locals.user;

const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Create authenticated client
const supabase = createClient(supabaseUrl, supabaseKey, {
  global: {
    headers: {
      Authorization: `Bearer ${accessToken}`,
    },
  },
});

let profile: any = null;
let activities: any[] = [];
let totalPosts: number = 0;
let totalUsers: number = 0;
let recentLogins: number = 0;
let apiResponseTime: string = '0 ms';
let apiResponseTrend: 'up' | 'down' | undefined = undefined;
let apiResponseTrendValue: string = '0%';

if (user) {
  const startTime = performance.now();

  try {
    // Fetch all dashboard data in parallel for efficiency
    const [
      { data: profileData },
      { data: activityData },
      { count: postsCount },
      { count: usersCount },
      { count: recentLoginsCount },
    ] = await Promise.all([
      supabase.from('admin_profiles').select('*').eq('id', user.id).single(),
      supabase
        .from('activity_logs')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false })
        .limit(5),
      supabase.from('posts').select('*', { count: 'exact', head: true }),
      supabase.from('admin_profiles').select('*', { count: 'exact', head: true }),
      supabase
        .from('activity_logs')
        .select('*', { count: 'exact', head: true })
        .eq('action', 'user_login')
        .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()),
    ]);

    profile = profileData;
    activities = activityData || [];
    totalPosts = postsCount || 0;
    totalUsers = usersCount || 0;
    recentLogins = recentLoginsCount || 0;

    const endTime = performance.now();
    const duration = Math.round(endTime - startTime);

    // Async log the metric and cleanup old logs (don't await to avoid blocking render)
    Promise.all([
      supabase.from('system_metrics').insert({
        metric_name: 'api_response_time',
        value: duration,
        unit: 'ms',
      }),
      supabase
        .from('system_metrics')
        .delete()
        .lt('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()),
    ]).then(([insertRes, deleteRes]) => {
      if (insertRes.error) console.error('Error logging metric:', insertRes.error);
      if (deleteRes.error) console.error('Error cleaning up metrics:', deleteRes.error);
    });

    // Fetch the average of the last 10 entries for a more stable metric,
    // and the 10 before that to calculate a trend.
    const { data: metricsData } = await supabase
      .from('system_metrics')
      .select('value')
      .eq('metric_name', 'api_response_time')
      .order('created_at', { ascending: false })
      .limit(20);

    if (metricsData && metricsData.length > 0) {
      const currentWindow = metricsData.slice(0, 10);
      const previousWindow = metricsData.slice(10, 20);

      const currentAvg =
        currentWindow.reduce((acc, curr) => acc + curr.value, 0) / currentWindow.length;
      apiResponseTime = `${Math.round(currentAvg)} ms`;

      if (previousWindow.length > 0) {
        const previousAvg =
          previousWindow.reduce((acc, curr) => acc + curr.value, 0) / previousWindow.length;
        const percentChange = ((currentAvg - previousAvg) / previousAvg) * 100;

        apiResponseTrendValue = `${Math.abs(percentChange).toFixed(1)}%`;
        apiResponseTrend = percentChange > 0 ? 'down' : 'up'; // Inverted because higher latency is "down/bad"
      }
    } else {
      apiResponseTime = `${duration} ms`;
    }
  } catch (error) {
    console.error('Error fetching dashboard data:', error);
  }
}
---

<Layout title="Admin Dashboard - Project Overlord" shouldPadHeader={true}>
  <div class="relative min-h-screen overflow-hidden">
    <!-- Background Effect -->
    <div class="fixed inset-0 w-full h-full bg-zinc-950 -z-10">
      <Balatro
        isRotate={true}
        mouseInteraction={true}
        pixelFilter={700}
        spinSpeed={1.5}
        client:load
      />
    </div>

    <!-- Overlay -->
    <div class="fixed inset-0 bg-gradient-to-b from-zinc-950/60 via-zinc-950/80 to-zinc-950 -z-10">
    </div>

    <!-- Dashboard Content -->
    <div class="relative z-10">
      <DashboardContent
        client:load
        user={user}
        profile={profile}
        activities={activities as any}
        totalPosts={totalPosts}
        totalUsers={totalUsers}
        recentLogins={recentLogins}
        apiResponseTime={apiResponseTime}
        apiResponseTrend={apiResponseTrend}
        apiResponseTrendValue={apiResponseTrendValue}
      />
    </div>
  </div>
</Layout>
